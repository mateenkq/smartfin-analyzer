# app.py

import os
from flask import Flask, request, render_template, redirect, url_for, session

# LangChain components
from langchain_community.document_loaders import PyPDFLoader
from langchain_community.vectorstores import Chroma
from langchain_openai import OpenAIEmbeddings, ChatOpenAI
from langchain.tools.tavily_search import TavilySearchResults
from langchain.tools import tool
from langgraph.graph import StateGraph, END
from langgraph.prebuilt import ToolNode
from langchain_core.messages import HumanMessage
from typing import TypedDict, Annotated, List
import operator

# Import Pydantic
from langchain_core.pydantic_v1 import BaseModel, Field

# Load API keys
from dotenv import load_dotenv
load_dotenv()

# --- Flask App Configuration ---
app = Flask(__name__)
app.secret_key = os.urandom(24)
app.config['UPLOAD_FOLDER'] = 'uploads'
os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)


# --- CHANGED: Added a highly detailed description for financial_metrics ---
class AnalysisResult(BaseModel):
    """A data model for the structured analysis of a financial document."""
    business_overview: str = Field(description="A concise summary of what the company does, its main products or services, and its market.")
    
    financial_metrics: List[List[str]] = Field(
        description=(
            "A table of key financial metrics represented as a list of lists. "
            "The first inner list MUST be the table headers (e.g., ['Financial Metric', '2023', '2022', '2021']). "
            "Subsequent inner lists are the data rows. You MUST attempt to find and include the following specific metrics in this order: "
            "Net Sales, Cost of Sales, Gross Margin, Research and Development Expenses, "
            "Cash, Cash Equivalents, and Marketable Securities, Property, Plant, and Equipment, Net, "
            "Commercial Paper, Total Term Debt, Working Capital, Cash Generated by Operating Activities, "
            "Cash Generated by/(Used in) Investing Activities, and Cash Used in Financing Activities. "
            "If a metric cannot be found, omit its row from the table."
        )
    )
    
    key_risks: List[str] = Field(description="A list summarizing 3-5 of the key risks to the business as described in the document.")

# --- LangChain Agent Components ---
llm = ChatOpenAI(temperature=0, model="gpt-4o")
structured_llm = llm.with_structured_output(AnalysisResult)
web_search_tool = TavilySearchResults(max_results=2)

class AgentState(TypedDict):
    messages: Annotated[list, operator.add]


# --- Core Web App Routes ---

@app.route('/')
def index():
    """Renders the main page."""
    return render_template('index.html',
                           business_overview=session.get('business_overview'),
                           financial_metrics=session.get('financial_metrics'),
                           key_risks=session.get('key_risks'),
                           search_result=session.get('search_result'),
                           filename=session.get('filename'))

@app.route('/upload', methods=['POST'])
def upload_file():
    """Handles PDF file upload and performs a comprehensive three-part analysis."""
    if 'file' not in request.files:
        return redirect(url_for('index'))
    
    file = request.files['file']
    if file.filename == '' or not file.filename.endswith('.pdf'):
        return redirect(url_for('index'))
    
    session.clear()
    
    filepath = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
    file.save(filepath)

    try:
        loader = PyPDFLoader(filepath)
        docs = loader.load()
        
        analysis_prompt = "From the provided financial document, perform a detailed analysis and provide the results based on the required JSON schema, paying close attention to the detailed list of financial metrics requested."
        analysis_response = structured_llm.invoke([HumanMessage(content=analysis_prompt, documents=docs)])
        
        session['business_overview'] = analysis_response.business_overview
        session['financial_metrics'] = analysis_response.financial_metrics
        session['key_risks'] = "\n".join(f"â€¢ {item}" for item in analysis_response.key_risks)

    except Exception as e:
        session['business_overview'] = f"An error occurred during analysis: {e}"
        session['financial_metrics'] = [] # Set to empty list on error
        session['key_risks'] = "Analysis failed."

    session['doc_path'] = filepath
    session['filename'] = file.filename
        
    return redirect(url_for('index'))

# The /search route remains unchanged
@app.route('/search', methods=['POST'])
def search():
    """Handles a search query by building and running the agent for the uploaded document."""
    query = request.form.get('query')
    doc_path = session.get('doc_path')

    if not query or not doc_path:
        return redirect(url_for('index'))

    try:
        loader = PyPDFLoader(doc_path)
        docs = loader.load_and_split()
        vectorstore = Chroma.from_documents(documents=docs, embedding=OpenAIEmbeddings())
        retriever = vectorstore.as_retriever()

        @tool
        def document_search(query: str):
            """Searches the content of the uploaded financial PDF document."""
            return retriever.invoke(query)

        session_tools = [document_search, web_search_tool]
        llm_with_tools = llm.bind_tools(session_tools)
        
        def assistant_node(state):
            response = llm_with_tools.invoke(state['messages'])
            return {"messages": [response]}

        tool_node = ToolNode(session_tools)
        def should_continue(state): return "continue" if state["messages"][-1].tool_calls else "end"

        workflow = StateGraph(AgentState)
        workflow.add_node("assistant", assistant_node)
        workflow.add_node("tools", tool_node)
        workflow.set_entry_point("assistant")
        workflow.add_conditional_edges("assistant", should_continue, {"continue": "tools", "end": END})
        workflow.add_edge("tools", "assistant")
        
        app_runnable = workflow.compile()

        inputs = {"messages": [HumanMessage(content=query)]}
        final_state = app_runnable.invoke(inputs)
        session['search_result'] = final_state['messages'][-1].content
    
    except Exception as e:
        session['search_result'] = f"An error occurred during search: {e}"

    return redirect(url_for('index'))

if __name__ == '__main__':
    app.run(debug=True)